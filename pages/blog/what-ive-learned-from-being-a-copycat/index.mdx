import PostLayout from "@/components/PostLayout";
import { ExternalLink } from "@/components/Link";
import Figure from "@/components/Figure";
import { FlexCenter } from "@/components/FlexContainer";

export const meta = {
  title: "What I've Learned from Being a Copycat",
  description:
    "frontend structure plan, re-usable components, frontend mobile-first",
  createdAt: "2021-07-15",
};

export default ({ children }) => (
  <PostLayout meta={meta}>{children}</PostLayout>
);

Last month when I was looking for a job and was afraid to take the first step, I immersed myself in building some practical frontend projects. I tried some Frontend Mentor's challenges, but I am not sure whether they're practical enough. So I decided to be a copycat and cloned <ExternalLink href="https://bejamas.io">bejamas.io</ExternalLink>, actually only the home page (the version before they updated their website at July 15, 2021). Bejamas is very beautiful and elegant in detail; I discovered it a year ago while looking up "what is jamstack" and instantly fell in love with this beautiful website. With a live website, I thought it would be definitely practical.

<FlexCenter>
  <ExternalLink href="https://github.com/cyishere/bejamas-copycat">
    Live Demo Page
  </ExternalLink>
  <ExternalLink href="https://github.com/cyishere/bejamas-copycat">
    Code on GitHub
  </ExternalLink>
</FlexCenter>

So I took Bejamas' home page as a design template and cloned it with <ExternalLink href="https://nextjs.org/">Next.js</ExternalLink>, <ExternalLink href="https://styled-components.com/">styled-components</ExternalLink>, and <ExternalLink href="https://www.sanity.io/">Sanity</ExternalLink> for the "services" and "blog posts" sections (taste some jam). I avoided looking at their source code except copied the CSS code for the box shadow and gradient (üò¨). It took me an unexpectedly long time to complete it, and some parts are still unfinished.

I've learned a lot during the production process. The following are the lessons:

## Mobile-first, but not too first

I've been reading articles about the mobile-first principle. As designers say it's "<ExternalLink href="https://medium.com/@Vincentxia77/what-is-mobile-first-design-why-its-important-how-to-make-it-7d3cf2e29d00">progress advancement</ExternalLink>". "First, we build a version for the relatively lower browser which includes the most basic functions and features. Then add interactions, more complicated effects on the basic version for tablet or PC." So I followed this principle to start, then I kinda stuck myself in a corner.

Because I didn't consider the complexity of the desktop version when I started structuring the DOM. That means I'll have to create a completely new DOM structure for a larger screen rather than relying on CSS to do the fancy responsive work. So after spending a significant amount of time refactoring my code, I ended up using three `<header>`s and letting the media query in CSS decide which one would be displayed which other two would be `display: none;`. I think it's a little messy.

The lesson I've learned here is **although starting with mobile-first, I need to think in the big picture, consider all the variants rather than "abandoning" the version for larger screens at first.**

Notes: I attempted to use <ExternalLink href="https://github.com/contra/react-responsive">react-responsive</ExternalLink>, but due to SSG in Next.js it became a bit tricky. Here's <ExternalLink href="https://nitayneeman.com/posts/combining-server-side-rendering-and-responsive-design-using-react/">an article about server-side rendering and responsive design</ExternalLink>. I'd also like to try the dependency <ExternalLink href="https://github.com/artsy/fresnel">fresnel</ExternalLink>.

## Plan first and document well

I tried to implement the concept of re-usable components in this project as much as possible. During coding, I assigned multiple tasks to one component, such as there's a `<TwoColumns />` component displayed as grid, because I wanted it to be used in every situation, I put several props on it. Then I forgot what they were and when I was supposed to use which...ü§¶üèª‚Äç‚ôÄÔ∏è

The lesson I've learned here is similar to the first one which **I need to plan ahead of time, consider all of the possibilities, and write document for them.**

There are several tools for writing documents for React projects; however, because this project is small, I decided to convert it to TypeScript in order to use types to specify variant props. (I could use `prop-types`, but I like TypeScript more and want to use it as much as possible. üòÑ)

## Round dashed gradient border

<Figure
  alt="Round dashed gradient border of bejamas.io"
  src="/img/blog/what-ive-learned-from-being-a-copycat/round-dashed-gradient-border.png"
/>

Bejamas wraps some logos with a round dashed gradient border. It's a minor aesthetic detail, but I spend a lot of time on it, despite the fact that the solution is quite simple. I didn't find the right approach at first. And I put it here: **`border-image` cannot create a round border.**

There're two solutions for this style, which I put in a codepen below. I used the second one in this project.

<p
  className="codepen"
  data-height={300}
  data-theme-id="light"
  data-default-tab="html,result"
  data-slug-hash="RwpXMGy"
  data-user="cyishere"
  style={{
    height: "300px",
    boxSizing: "border-box",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    border: "2px solid",
    margin: "1em 0",
    padding: "1em",
  }}
>
  <span>
    See the Pen{" "}
    <a href="https://codepen.io/cyishere/pen/RwpXMGy">
      Round Dashed Gradient Border with CSS
    </a>{" "}
    by Irini (<a href="https://codepen.io/cyishere">@cyishere</a>) on{" "}
    <a href="https://codepen.io">CodePen</a>.
  </span>
</p>

<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>

The first is to use a full-color pseudo-element and place it beneath the main element. The main element has a dashed border that matches its background. As a result, the dashed border's gaps reveal the gradient color beneath, giving the appearance of a round dashed gradient border. The key here is to use `background-clip: padding-box;`.

The second is similar to the first, but instead of layered elements, it employs _layered background images_. With the help of `background-clip` the top layer of the background images lets the dashed border reveal the gradient image beneath and produce the same effect as the first one.

Both solutions are straightforward; what matters here is finding the right "mental model". But what I've learned is beyond it: **we shouldn't be afraid of something that appears difficult because it may turn out to be simple once we get our hands dirty.** ÔºàNow, I need to figure out the right mental model for the jar animation in the hero section; still don't know how to make it...üòë)

## Looping LEGO animation

On Bejamas' home page, right after the "round dashed gradient border" section there's a looping animation that stacks three lego blocks on top of each other again and again and again, to infinity and beyond.

The tricky part is that the "boxes" in CSS is a one-way stack. How did I manage to stack the first one on top of the last?
